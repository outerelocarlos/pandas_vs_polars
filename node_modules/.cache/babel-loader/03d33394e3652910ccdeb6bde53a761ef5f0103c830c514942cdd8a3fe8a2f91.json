{"ast":null,"code":"/*  ansi_up.js\n *  author : Dru Nelson\n *  license : MIT\n *  http://github.com/drudru/ansi_up\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['exports'], factory);\n  } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n    // CommonJS\n    factory(exports);\n  } else {\n    // Browser globals\n    var exp = {};\n    factory(exp);\n    root.AnsiUp = exp.default;\n  }\n})(this, function (exports) {\n  \"use strict\";\n\n  var __makeTemplateObject = this && this.__makeTemplateObject || function (cooked, raw) {\n    if (Object.defineProperty) {\n      Object.defineProperty(cooked, \"raw\", {\n        value: raw\n      });\n    } else {\n      cooked.raw = raw;\n    }\n    return cooked;\n  };\n  var PacketKind;\n  (function (PacketKind) {\n    PacketKind[PacketKind[\"EOS\"] = 0] = \"EOS\";\n    PacketKind[PacketKind[\"Text\"] = 1] = \"Text\";\n    PacketKind[PacketKind[\"Incomplete\"] = 2] = \"Incomplete\";\n    PacketKind[PacketKind[\"ESC\"] = 3] = \"ESC\";\n    PacketKind[PacketKind[\"Unknown\"] = 4] = \"Unknown\";\n    PacketKind[PacketKind[\"SGR\"] = 5] = \"SGR\";\n    PacketKind[PacketKind[\"OSCURL\"] = 6] = \"OSCURL\";\n  })(PacketKind || (PacketKind = {}));\n  var AnsiUp = function () {\n    function AnsiUp() {\n      this.VERSION = \"5.2.1\";\n      this.setup_palettes();\n      this._use_classes = false;\n      this.bold = false;\n      this.italic = false;\n      this.underline = false;\n      this.fg = this.bg = null;\n      this._buffer = '';\n      this._url_whitelist = {\n        'http': 1,\n        'https': 1\n      };\n      this._escape_html = true;\n    }\n    Object.defineProperty(AnsiUp.prototype, \"use_classes\", {\n      get: function () {\n        return this._use_classes;\n      },\n      set: function (arg) {\n        this._use_classes = arg;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AnsiUp.prototype, \"url_whitelist\", {\n      get: function () {\n        return this._url_whitelist;\n      },\n      set: function (arg) {\n        this._url_whitelist = arg;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AnsiUp.prototype, \"escape_html\", {\n      get: function () {\n        return this._escape_html;\n      },\n      set: function (arg) {\n        this._escape_html = arg;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    AnsiUp.prototype.setup_palettes = function () {\n      var _this = this;\n      this.ansi_colors = [[{\n        rgb: [0, 0, 0],\n        class_name: \"ansi-black\"\n      }, {\n        rgb: [187, 0, 0],\n        class_name: \"ansi-red\"\n      }, {\n        rgb: [0, 187, 0],\n        class_name: \"ansi-green\"\n      }, {\n        rgb: [187, 187, 0],\n        class_name: \"ansi-yellow\"\n      }, {\n        rgb: [0, 0, 187],\n        class_name: \"ansi-blue\"\n      }, {\n        rgb: [187, 0, 187],\n        class_name: \"ansi-magenta\"\n      }, {\n        rgb: [0, 187, 187],\n        class_name: \"ansi-cyan\"\n      }, {\n        rgb: [255, 255, 255],\n        class_name: \"ansi-white\"\n      }], [{\n        rgb: [85, 85, 85],\n        class_name: \"ansi-bright-black\"\n      }, {\n        rgb: [255, 85, 85],\n        class_name: \"ansi-bright-red\"\n      }, {\n        rgb: [0, 255, 0],\n        class_name: \"ansi-bright-green\"\n      }, {\n        rgb: [255, 255, 85],\n        class_name: \"ansi-bright-yellow\"\n      }, {\n        rgb: [85, 85, 255],\n        class_name: \"ansi-bright-blue\"\n      }, {\n        rgb: [255, 85, 255],\n        class_name: \"ansi-bright-magenta\"\n      }, {\n        rgb: [85, 255, 255],\n        class_name: \"ansi-bright-cyan\"\n      }, {\n        rgb: [255, 255, 255],\n        class_name: \"ansi-bright-white\"\n      }]];\n      this.palette_256 = [];\n      this.ansi_colors.forEach(function (palette) {\n        palette.forEach(function (rec) {\n          _this.palette_256.push(rec);\n        });\n      });\n      var levels = [0, 95, 135, 175, 215, 255];\n      for (var r = 0; r < 6; ++r) {\n        for (var g = 0; g < 6; ++g) {\n          for (var b = 0; b < 6; ++b) {\n            var col = {\n              rgb: [levels[r], levels[g], levels[b]],\n              class_name: 'truecolor'\n            };\n            this.palette_256.push(col);\n          }\n        }\n      }\n      var grey_level = 8;\n      for (var i = 0; i < 24; ++i, grey_level += 10) {\n        var gry = {\n          rgb: [grey_level, grey_level, grey_level],\n          class_name: 'truecolor'\n        };\n        this.palette_256.push(gry);\n      }\n    };\n    AnsiUp.prototype.escape_txt_for_html = function (txt) {\n      if (!this._escape_html) return txt;\n      return txt.replace(/[&<>\"']/gm, function (str) {\n        if (str === \"&\") return \"&amp;\";\n        if (str === \"<\") return \"&lt;\";\n        if (str === \">\") return \"&gt;\";\n        if (str === \"\\\"\") return \"&quot;\";\n        if (str === \"'\") return \"&#x27;\";\n      });\n    };\n    AnsiUp.prototype.append_buffer = function (txt) {\n      var str = this._buffer + txt;\n      this._buffer = str;\n    };\n    AnsiUp.prototype.get_next_packet = function () {\n      var pkt = {\n        kind: PacketKind.EOS,\n        text: '',\n        url: ''\n      };\n      var len = this._buffer.length;\n      if (len == 0) return pkt;\n      var pos = this._buffer.indexOf(\"\\x1B\");\n      if (pos == -1) {\n        pkt.kind = PacketKind.Text;\n        pkt.text = this._buffer;\n        this._buffer = '';\n        return pkt;\n      }\n      if (pos > 0) {\n        pkt.kind = PacketKind.Text;\n        pkt.text = this._buffer.slice(0, pos);\n        this._buffer = this._buffer.slice(pos);\n        return pkt;\n      }\n      if (pos == 0) {\n        if (len < 3) {\n          pkt.kind = PacketKind.Incomplete;\n          return pkt;\n        }\n        var next_char = this._buffer.charAt(1);\n        if (next_char != '[' && next_char != ']' && next_char != '(') {\n          pkt.kind = PacketKind.ESC;\n          pkt.text = this._buffer.slice(0, 1);\n          this._buffer = this._buffer.slice(1);\n          return pkt;\n        }\n        if (next_char == '[') {\n          if (!this._csi_regex) {\n            this._csi_regex = rgx(__makeTemplateObject([\"\\n                        ^                           # beginning of line\\n                                                    #\\n                                                    # First attempt\\n                        (?:                         # legal sequence\\n                          \\u001B[                      # CSI\\n                          ([<-?]?)              # private-mode char\\n                          ([d;]*)                    # any digits or semicolons\\n                          ([ -/]?               # an intermediate modifier\\n                          [@-~])                # the command\\n                        )\\n                        |                           # alternate (second attempt)\\n                        (?:                         # illegal sequence\\n                          \\u001B[                      # CSI\\n                          [ -~]*                # anything legal\\n                          ([\\0-\\u001F:])              # anything illegal\\n                        )\\n                    \"], [\"\\n                        ^                           # beginning of line\\n                                                    #\\n                                                    # First attempt\\n                        (?:                         # legal sequence\\n                          \\\\x1b\\\\[                      # CSI\\n                          ([\\\\x3c-\\\\x3f]?)              # private-mode char\\n                          ([\\\\d;]*)                    # any digits or semicolons\\n                          ([\\\\x20-\\\\x2f]?               # an intermediate modifier\\n                          [\\\\x40-\\\\x7e])                # the command\\n                        )\\n                        |                           # alternate (second attempt)\\n                        (?:                         # illegal sequence\\n                          \\\\x1b\\\\[                      # CSI\\n                          [\\\\x20-\\\\x7e]*                # anything legal\\n                          ([\\\\x00-\\\\x1f:])              # anything illegal\\n                        )\\n                    \"]));\n          }\n          var match = this._buffer.match(this._csi_regex);\n          if (match === null) {\n            pkt.kind = PacketKind.Incomplete;\n            return pkt;\n          }\n          if (match[4]) {\n            pkt.kind = PacketKind.ESC;\n            pkt.text = this._buffer.slice(0, 1);\n            this._buffer = this._buffer.slice(1);\n            return pkt;\n          }\n          if (match[1] != '' || match[3] != 'm') pkt.kind = PacketKind.Unknown;else pkt.kind = PacketKind.SGR;\n          pkt.text = match[2];\n          var rpos = match[0].length;\n          this._buffer = this._buffer.slice(rpos);\n          return pkt;\n        } else if (next_char == ']') {\n          if (len < 4) {\n            pkt.kind = PacketKind.Incomplete;\n            return pkt;\n          }\n          if (this._buffer.charAt(2) != '8' || this._buffer.charAt(3) != ';') {\n            pkt.kind = PacketKind.ESC;\n            pkt.text = this._buffer.slice(0, 1);\n            this._buffer = this._buffer.slice(1);\n            return pkt;\n          }\n          if (!this._osc_st) {\n            this._osc_st = rgxG(__makeTemplateObject([\"\\n                        (?:                         # legal sequence\\n                          (\\u001B\\\\)                    # ESC                           |                           # alternate\\n                          (\\u0007)                      # BEL (what xterm did)\\n                        )\\n                        |                           # alternate (second attempt)\\n                        (                           # illegal sequence\\n                          [\\0-\\u0006]                 # anything illegal\\n                          |                           # alternate\\n                          [\\b-\\u001A]                 # anything illegal\\n                          |                           # alternate\\n                          [\\u001C-\\u001F]                 # anything illegal\\n                        )\\n                    \"], [\"\\n                        (?:                         # legal sequence\\n                          (\\\\x1b\\\\\\\\)                    # ESC \\\\\\n                          |                           # alternate\\n                          (\\\\x07)                      # BEL (what xterm did)\\n                        )\\n                        |                           # alternate (second attempt)\\n                        (                           # illegal sequence\\n                          [\\\\x00-\\\\x06]                 # anything illegal\\n                          |                           # alternate\\n                          [\\\\x08-\\\\x1a]                 # anything illegal\\n                          |                           # alternate\\n                          [\\\\x1c-\\\\x1f]                 # anything illegal\\n                        )\\n                    \"]));\n          }\n          this._osc_st.lastIndex = 0;\n          {\n            var match_1 = this._osc_st.exec(this._buffer);\n            if (match_1 === null) {\n              pkt.kind = PacketKind.Incomplete;\n              return pkt;\n            }\n            if (match_1[3]) {\n              pkt.kind = PacketKind.ESC;\n              pkt.text = this._buffer.slice(0, 1);\n              this._buffer = this._buffer.slice(1);\n              return pkt;\n            }\n          }\n          {\n            var match_2 = this._osc_st.exec(this._buffer);\n            if (match_2 === null) {\n              pkt.kind = PacketKind.Incomplete;\n              return pkt;\n            }\n            if (match_2[3]) {\n              pkt.kind = PacketKind.ESC;\n              pkt.text = this._buffer.slice(0, 1);\n              this._buffer = this._buffer.slice(1);\n              return pkt;\n            }\n          }\n          if (!this._osc_regex) {\n            this._osc_regex = rgx(__makeTemplateObject([\"\\n                        ^                           # beginning of line\\n                                                    #\\n                        \\u001B]8;                    # OSC Hyperlink\\n                        [ -:<-~]*       # params (excluding ;)\\n                        ;                           # end of params\\n                        ([!-~]{0,512})        # URL capture\\n                        (?:                         # ST\\n                          (?:\\u001B\\\\)                  # ESC                           |                           # alternate\\n                          (?:\\u0007)                    # BEL (what xterm did)\\n                        )\\n                        ([ -~]+)              # TEXT capture\\n                        \\u001B]8;;                   # OSC Hyperlink End\\n                        (?:                         # ST\\n                          (?:\\u001B\\\\)                  # ESC                           |                           # alternate\\n                          (?:\\u0007)                    # BEL (what xterm did)\\n                        )\\n                    \"], [\"\\n                        ^                           # beginning of line\\n                                                    #\\n                        \\\\x1b\\\\]8;                    # OSC Hyperlink\\n                        [\\\\x20-\\\\x3a\\\\x3c-\\\\x7e]*       # params (excluding ;)\\n                        ;                           # end of params\\n                        ([\\\\x21-\\\\x7e]{0,512})        # URL capture\\n                        (?:                         # ST\\n                          (?:\\\\x1b\\\\\\\\)                  # ESC \\\\\\n                          |                           # alternate\\n                          (?:\\\\x07)                    # BEL (what xterm did)\\n                        )\\n                        ([\\\\x20-\\\\x7e]+)              # TEXT capture\\n                        \\\\x1b\\\\]8;;                   # OSC Hyperlink End\\n                        (?:                         # ST\\n                          (?:\\\\x1b\\\\\\\\)                  # ESC \\\\\\n                          |                           # alternate\\n                          (?:\\\\x07)                    # BEL (what xterm did)\\n                        )\\n                    \"]));\n          }\n          var match = this._buffer.match(this._osc_regex);\n          if (match === null) {\n            pkt.kind = PacketKind.ESC;\n            pkt.text = this._buffer.slice(0, 1);\n            this._buffer = this._buffer.slice(1);\n            return pkt;\n          }\n          pkt.kind = PacketKind.OSCURL;\n          pkt.url = match[1];\n          pkt.text = match[2];\n          var rpos = match[0].length;\n          this._buffer = this._buffer.slice(rpos);\n          return pkt;\n        } else if (next_char == '(') {\n          pkt.kind = PacketKind.Unknown;\n          this._buffer = this._buffer.slice(3);\n          return pkt;\n        }\n      }\n    };\n    AnsiUp.prototype.ansi_to_html = function (txt) {\n      this.append_buffer(txt);\n      var blocks = [];\n      while (true) {\n        var packet = this.get_next_packet();\n        if (packet.kind == PacketKind.EOS || packet.kind == PacketKind.Incomplete) break;\n        if (packet.kind == PacketKind.ESC || packet.kind == PacketKind.Unknown) continue;\n        if (packet.kind == PacketKind.Text) blocks.push(this.transform_to_html(this.with_state(packet)));else if (packet.kind == PacketKind.SGR) this.process_ansi(packet);else if (packet.kind == PacketKind.OSCURL) blocks.push(this.process_hyperlink(packet));\n      }\n      return blocks.join(\"\");\n    };\n    AnsiUp.prototype.with_state = function (pkt) {\n      return {\n        bold: this.bold,\n        italic: this.italic,\n        underline: this.underline,\n        fg: this.fg,\n        bg: this.bg,\n        text: pkt.text\n      };\n    };\n    AnsiUp.prototype.process_ansi = function (pkt) {\n      var sgr_cmds = pkt.text.split(';');\n      while (sgr_cmds.length > 0) {\n        var sgr_cmd_str = sgr_cmds.shift();\n        var num = parseInt(sgr_cmd_str, 10);\n        if (isNaN(num) || num === 0) {\n          this.fg = this.bg = null;\n          this.bold = false;\n          this.italic = false;\n          this.underline = false;\n        } else if (num === 1) {\n          this.bold = true;\n        } else if (num === 3) {\n          this.italic = true;\n        } else if (num === 4) {\n          this.underline = true;\n        } else if (num === 22) {\n          this.bold = false;\n        } else if (num === 23) {\n          this.italic = false;\n        } else if (num === 24) {\n          this.underline = false;\n        } else if (num === 39) {\n          this.fg = null;\n        } else if (num === 49) {\n          this.bg = null;\n        } else if (num >= 30 && num < 38) {\n          this.fg = this.ansi_colors[0][num - 30];\n        } else if (num >= 40 && num < 48) {\n          this.bg = this.ansi_colors[0][num - 40];\n        } else if (num >= 90 && num < 98) {\n          this.fg = this.ansi_colors[1][num - 90];\n        } else if (num >= 100 && num < 108) {\n          this.bg = this.ansi_colors[1][num - 100];\n        } else if (num === 38 || num === 48) {\n          if (sgr_cmds.length > 0) {\n            var is_foreground = num === 38;\n            var mode_cmd = sgr_cmds.shift();\n            if (mode_cmd === '5' && sgr_cmds.length > 0) {\n              var palette_index = parseInt(sgr_cmds.shift(), 10);\n              if (palette_index >= 0 && palette_index <= 255) {\n                if (is_foreground) this.fg = this.palette_256[palette_index];else this.bg = this.palette_256[palette_index];\n              }\n            }\n            if (mode_cmd === '2' && sgr_cmds.length > 2) {\n              var r = parseInt(sgr_cmds.shift(), 10);\n              var g = parseInt(sgr_cmds.shift(), 10);\n              var b = parseInt(sgr_cmds.shift(), 10);\n              if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {\n                var c = {\n                  rgb: [r, g, b],\n                  class_name: 'truecolor'\n                };\n                if (is_foreground) this.fg = c;else this.bg = c;\n              }\n            }\n          }\n        }\n      }\n    };\n    AnsiUp.prototype.transform_to_html = function (fragment) {\n      var txt = fragment.text;\n      if (txt.length === 0) return txt;\n      txt = this.escape_txt_for_html(txt);\n      if (!fragment.bold && !fragment.italic && !fragment.underline && fragment.fg === null && fragment.bg === null) return txt;\n      var styles = [];\n      var classes = [];\n      var fg = fragment.fg;\n      var bg = fragment.bg;\n      if (fragment.bold) styles.push('font-weight:bold');\n      if (fragment.italic) styles.push('font-style:italic');\n      if (fragment.underline) styles.push('text-decoration:underline');\n      if (!this._use_classes) {\n        if (fg) styles.push(\"color:rgb(\" + fg.rgb.join(',') + \")\");\n        if (bg) styles.push(\"background-color:rgb(\" + bg.rgb + \")\");\n      } else {\n        if (fg) {\n          if (fg.class_name !== 'truecolor') {\n            classes.push(fg.class_name + \"-fg\");\n          } else {\n            styles.push(\"color:rgb(\" + fg.rgb.join(',') + \")\");\n          }\n        }\n        if (bg) {\n          if (bg.class_name !== 'truecolor') {\n            classes.push(bg.class_name + \"-bg\");\n          } else {\n            styles.push(\"background-color:rgb(\" + bg.rgb.join(',') + \")\");\n          }\n        }\n      }\n      var class_string = '';\n      var style_string = '';\n      if (classes.length) class_string = \" class=\\\"\" + classes.join(' ') + \"\\\"\";\n      if (styles.length) style_string = \" style=\\\"\" + styles.join(';') + \"\\\"\";\n      return \"<span\" + style_string + class_string + \">\" + txt + \"</span>\";\n    };\n    ;\n    AnsiUp.prototype.process_hyperlink = function (pkt) {\n      var parts = pkt.url.split(':');\n      if (parts.length < 1) return '';\n      if (!this._url_whitelist[parts[0]]) return '';\n      var result = \"<a href=\\\"\" + this.escape_txt_for_html(pkt.url) + \"\\\">\" + this.escape_txt_for_html(pkt.text) + \"</a>\";\n      return result;\n    };\n    return AnsiUp;\n  }();\n  function rgx(tmplObj) {\n    var subst = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      subst[_i - 1] = arguments[_i];\n    }\n    var regexText = tmplObj.raw[0];\n    var wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n    var txt2 = regexText.replace(wsrgx, '');\n    return new RegExp(txt2);\n  }\n  function rgxG(tmplObj) {\n    var subst = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      subst[_i - 1] = arguments[_i];\n    }\n    var regexText = tmplObj.raw[0];\n    var wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n    var txt2 = regexText.replace(wsrgx, '');\n    return new RegExp(txt2, 'g');\n  }\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = AnsiUp;\n});","map":{"version":3,"names":["root","factory","define","amd","exports","nodeName","exp","AnsiUp","default","__makeTemplateObject","cooked","raw","Object","defineProperty","value","PacketKind","VERSION","setup_palettes","_use_classes","bold","italic","underline","fg","bg","prototype","arg","_url_whitelist","enumerable","configurable","get","_escape_html","set","_this","ansi_colors","rgb","class_name","palette_256","forEach","palette","rec","push","levels","r","g","b","col","grey_level","i","gry","escape_txt_for_html","txt","replace","str","_buffer","indexOf","kind","Text","text","slice","pos","pkt","next_char","charAt","ESC","_csi_regex","rgx","match","Incomplete","length","rpos","len","_osc_st","rgxG","lastIndex","match_1","exec","_osc_regex","OSCURL","url","Unknown","ansi_to_html","append_buffer","blocks","packet","get_next_packet","EOS","transform_to_html","with_state","SGR","process_ansi","process_hyperlink","join","sgr_cmds","split","sgr_cmd_str","shift","num","parseInt","isNaN","palette_index","is_foreground","mode_cmd","c","fragment","styles","classes","class_string","style_string","parts"],"sources":["C:\\Users\\outereca\\Documents\\React_Polars\\my-dashboard\\node_modules\\ansi_up\\ansi_up.ts"],"sourcesContent":["/* ansi_up.js\n * author : Dru Nelson\n * license : MIT\n * http://github.com/drudru/ansi_up\n */\n\n\"use strict\";\n\n//\n// INTERFACES\n//\n\ninterface AU_Color\n{\n    rgb:number[];\n    class_name:string;\n}\n\n// Represents the output of process_ansi(): a snapshot of the AnsiUp state machine\n// at a given point in time, which wraps a fragment of text. This would allow deferred\n// processing of text fragments and colors, if ever needed.\ninterface TextWithAttr {\n    fg:AU_Color;\n    bg:AU_Color;\n    bold:boolean;\n    italic: boolean;\n    underline: boolean;\n    text:string;\n}\n\n// Used internally when breaking up the raw text into packets\n\nenum PacketKind {\n    EOS,\n    Text,\n    Incomplete,         // An Incomplete ESC sequence\n    ESC,                // A single ESC char - random\n    Unknown,            // A valid CSI but not an SGR code\n    SGR,                // Select Graphic Rendition\n    OSCURL,             // Operating System Command\n}\n\ninterface TextPacket {\n    kind:PacketKind;\n    text:string;\n     url:string;\n}\n\n//\n// MAIN CLASS\n//\n\nclass AnsiUp\n{\n    VERSION = \"5.2.1\";\n\n    //\n    // *** SEE README ON GITHUB FOR PUBLIC API ***\n    //\n\n    // 256 Colors Palette\n    // CSS RGB strings - ex. \"255, 255, 255\"\n    private ansi_colors:AU_Color[][];\n    private palette_256:AU_Color[];\n\n    private fg:AU_Color;\n    private bg:AU_Color;\n    private bold:boolean;\n    private italic: boolean;\n    private underline:boolean;\n    private _use_classes:boolean;\n\n    private _csi_regex:RegExp;\n\n    private _osc_st:RegExp;\n    private _osc_regex:RegExp;\n\n    private _url_whitelist:{};\n    private _escape_html:boolean;\n\n    private _buffer:string;\n\n    constructor()\n    {\n        // All construction occurs here\n        this.setup_palettes();\n        this._use_classes = false;\n\n        this.bold = false;\n        this.italic = false;\n        this.underline = false;\n        this.fg = this.bg = null;\n\n        this._buffer = '';\n\n        this._url_whitelist = { 'http':1, 'https':1 };\n        this._escape_html = true;\n    }\n\n    set use_classes(arg:boolean)\n    {\n        this._use_classes = arg;\n    }\n\n    get use_classes():boolean\n    {\n        return this._use_classes;\n    }\n\n    set url_whitelist(arg:{})\n    {\n        this._url_whitelist = arg;\n    }\n\n    get url_whitelist():{}\n    {\n        return this._url_whitelist;\n    }\n\n    set escape_html(arg:boolean)\n    {\n        this._escape_html = arg;\n    }\n\n    get escape_html():boolean\n    {\n        return this._escape_html;\n    }\n\n\n    private setup_palettes():void\n    {\n        this.ansi_colors =\n        [\n            // Normal colors\n            [\n                { rgb: [  0,   0,   0],  class_name: \"ansi-black\"   },\n                { rgb: [187,   0,   0],  class_name: \"ansi-red\"     },\n                { rgb: [  0, 187,   0],  class_name: \"ansi-green\"   },\n                { rgb: [187, 187,   0],  class_name: \"ansi-yellow\"  },\n                { rgb: [  0,   0, 187],  class_name: \"ansi-blue\"    },\n                { rgb: [187,   0, 187],  class_name: \"ansi-magenta\" },\n                { rgb: [  0, 187, 187],  class_name: \"ansi-cyan\"    },\n                { rgb: [255, 255, 255],  class_name: \"ansi-white\"   }\n            ],\n\n            // Bright colors\n            [\n                { rgb: [ 85,  85,  85],  class_name: \"ansi-bright-black\"   },\n                { rgb: [255,  85,  85],  class_name: \"ansi-bright-red\"     },\n                { rgb: [  0, 255,   0],  class_name: \"ansi-bright-green\"   },\n                { rgb: [255, 255,  85],  class_name: \"ansi-bright-yellow\"  },\n                { rgb: [ 85,  85, 255],  class_name: \"ansi-bright-blue\"    },\n                { rgb: [255,  85, 255],  class_name: \"ansi-bright-magenta\" },\n                { rgb: [ 85, 255, 255],  class_name: \"ansi-bright-cyan\"    },\n                { rgb: [255, 255, 255],  class_name: \"ansi-bright-white\"   }\n            ]\n        ];\n\n        this.palette_256 = [];\n\n        // Index 0..15 : Ansi-Colors\n        this.ansi_colors.forEach( palette => {\n            palette.forEach( rec => {\n                this.palette_256.push(rec);\n            });\n        });\n\n        // Index 16..231 : RGB 6x6x6\n        // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n        let levels = [0, 95, 135, 175, 215, 255];\n        for (let r = 0; r < 6; ++r) {\n            for (let g = 0; g < 6; ++g) {\n                for (let b = 0; b < 6; ++b) {\n                    let col = {rgb:[levels[r], levels[g], levels[b]], class_name:'truecolor'};\n                    this.palette_256.push(col);\n                }\n            }\n        }\n\n        // Index 232..255 : Grayscale\n        let grey_level = 8;\n        for (let i = 0; i < 24; ++i, grey_level += 10) {\n            let gry = {rgb:[grey_level, grey_level, grey_level], class_name:'truecolor'};\n            this.palette_256.push(gry);\n        }\n    }\n\n    private escape_txt_for_html(txt:string):string\n    {\n      if (!this._escape_html)\n          return txt;\n      return txt.replace(/[&<>\"']/gm, (str) => {\n        if (str === \"&\")  return \"&amp;\";\n        if (str === \"<\")  return \"&lt;\";\n        if (str === \">\")  return \"&gt;\";\n        if (str === \"\\\"\") return \"&quot;\";\n        if (str === \"'\")  return \"&#x27;\";\n      });\n    }\n\n    private append_buffer(txt:string) {\n\n        var str = this._buffer + txt;\n        this._buffer = str;\n    }\n\n    private get_next_packet():TextPacket {\n\n        var pkt =\n            {\n                kind: PacketKind.EOS,\n                text: '',\n                 url: ''\n            } ;\n\n        var len = this._buffer.length;\n        if (len == 0)\n            return pkt;\n\n        var pos = this._buffer.indexOf(\"\\x1B\");\n\n        // The most common case, no ESC codes\n        if (pos == -1)\n        {\n            pkt.kind = PacketKind.Text;\n            pkt.text = this._buffer;\n            this._buffer = '';\n            return pkt;\n        }\n\n        if (pos > 0)\n        {\n            pkt.kind = PacketKind.Text;\n            pkt.text = this._buffer.slice(0, pos);\n            this._buffer = this._buffer.slice(pos);\n            return pkt;\n        }\n\n        // NOW WE HANDLE ESCAPES\n        if (pos == 0)\n        {\n            // All of the sequences typically need at least 3 characters\n            // So, wait until we have at least that many\n            if (len < 3)\n            {\n                pkt.kind = PacketKind.Incomplete;\n                return pkt;\n            }\n\n            var next_char = this._buffer.charAt(1);\n\n            // We treat this as a single ESC\n            // No transformation\n            if ((next_char != '[') && (next_char != ']') && (next_char != '('))\n            {\n                pkt.kind = PacketKind.ESC;\n                pkt.text = this._buffer.slice(0, 1);\n                this._buffer = this._buffer.slice(1);\n                return pkt;\n            }\n\n            // OK is this an SGR or OSC that we handle\n\n            // SGR CHECK\n            if (next_char == '[')\n            {\n                // We do this regex initialization here so\n                // we can keep the regex close to its use (Readability)\n\n                // All ansi codes are typically in the following format.\n                // We parse it and focus specifically on the\n                // graphics commands (SGR)\n                //\n                // CONTROL-SEQUENCE-INTRODUCER CSI             (ESC, '[')\n                // PRIVATE-MODE-CHAR                           (!, <, >, ?)\n                // Numeric parameters separated by semicolons  ('0' - '9', ';')\n                // Intermediate-modifiers                      (0x20 - 0x2f)\n                // COMMAND-CHAR                                (0x40 - 0x7e)\n                //\n\n                if (!this._csi_regex) {\n\n                    this._csi_regex = rgx`\n                        ^                           # beginning of line\n                                                    #\n                                                    # First attempt\n                        (?:                         # legal sequence\n                          \\x1b\\[                      # CSI\n                          ([\\x3c-\\x3f]?)              # private-mode char\n                          ([\\d;]*)                    # any digits or semicolons\n                          ([\\x20-\\x2f]?               # an intermediate modifier\n                          [\\x40-\\x7e])                # the command\n                        )\n                        |                           # alternate (second attempt)\n                        (?:                         # illegal sequence\n                          \\x1b\\[                      # CSI\n                          [\\x20-\\x7e]*                # anything legal\n                          ([\\x00-\\x1f:])              # anything illegal\n                        )\n                    `;\n                }\n\n                let match = this._buffer.match(this._csi_regex);\n\n                // This match is guaranteed to terminate (even on\n                // invalid input). The key is to match on legal and\n                // illegal sequences.\n                // The first alternate matches everything legal and\n                // the second matches everything illegal.\n                //\n                // If it doesn't match, then we have not received\n                // either the full sequence or an illegal sequence.\n                // If it does match, the presence of field 4 tells\n                // us whether it was legal or illegal.\n\n                if (match === null)\n                {\n                    pkt.kind = PacketKind.Incomplete;\n                    return pkt;\n                }\n\n                // match is an array\n                // 0 - total match\n                // 1 - private mode chars group\n                // 2 - digits and semicolons group\n                // 3 - command\n                // 4 - illegal char\n\n                if (match[4])\n                {\n                    // Illegal sequence, just remove the ESC\n                    pkt.kind = PacketKind.ESC;\n                    pkt.text = this._buffer.slice(0, 1);\n                    this._buffer = this._buffer.slice(1);\n                    return pkt;\n                }\n\n                // If not a valid SGR, we don't handle\n                if ( (match[1] != '') || (match[3] != 'm'))\n                    pkt.kind = PacketKind.Unknown;\n                else\n                    pkt.kind = PacketKind.SGR;\n\n                pkt.text = match[2] // Just the parameters\n\n                var rpos = match[0].length;\n                this._buffer = this._buffer.slice(rpos);\n                return pkt;\n            }\n            else\n            // OSC CHECK\n            if (next_char == ']')\n            {\n                if (len < 4)\n                {\n                        pkt.kind = PacketKind.Incomplete;\n                        return pkt;\n                }\n\n                if (    (this._buffer.charAt(2) != '8')\n                     || (this._buffer.charAt(3) != ';') )\n                {\n                    // This is not a match, so we'll just treat it as ESC\n                    pkt.kind = PacketKind.ESC;\n                    pkt.text = this._buffer.slice(0, 1);\n                    this._buffer = this._buffer.slice(1);\n                    return pkt;\n                }\n\n                // We do this regex initialization here so\n                // we can keep the regex close to its use (Readability)\n\n                // Matching a Hyperlink OSC with a regex is difficult\n                // because Javascript's regex engine doesn't support\n                // 'partial match' support.\n                //\n                // Therefore, we require the system to match the\n                // string-terminator(ST) before attempting a match.\n                // Once we find it, we attempt the Hyperlink-Begin\n                // match.\n                // If that goes ok, we scan forward for the next\n                // ST.\n                // Finally, we try to match it all and return\n                // the sequence.\n                // Also, it is important to note that we consider\n                // certain control characters as an invalidation of\n                // the entire sequence.\n\n                // We do regex initializations here so\n                // we can keep the regex close to its use (Readability)\n\n\n                // STRING-TERMINATOR\n                // This is likely to terminate in most scenarios\n                // because it will terminate on a newline\n\n                if (!this._osc_st) {\n\n                    this._osc_st = rgxG`\n                        (?:                         # legal sequence\n                          (\\x1b\\\\)                    # ESC \\\n                          |                           # alternate\n                          (\\x07)                      # BEL (what xterm did)\n                        )\n                        |                           # alternate (second attempt)\n                        (                           # illegal sequence\n                          [\\x00-\\x06]                 # anything illegal\n                          |                           # alternate\n                          [\\x08-\\x1a]                 # anything illegal\n                          |                           # alternate\n                          [\\x1c-\\x1f]                 # anything illegal\n                        )\n                    `;\n                }\n\n                // VERY IMPORTANT\n                // We do a stateful regex match with exec.\n                // If the regex is global, and it used with 'exec',\n                // then it will search starting at the 'lastIndex'\n                // If it matches, the regex can be used again to\n                // find the next match.\n                this._osc_st.lastIndex = 0;\n\n\n                {\n                    let match = this._osc_st.exec( this._buffer );\n\n                    if (match === null)\n                    {\n                        pkt.kind = PacketKind.Incomplete;\n                        return pkt;\n                    }\n\n                    // If an illegal character was found, bail on the match\n                    if (match[3])\n                    {\n                        // Illegal sequence, just remove the ESC\n                        pkt.kind = PacketKind.ESC;\n                        pkt.text = this._buffer.slice(0, 1);\n                        this._buffer = this._buffer.slice(1);\n                        return pkt;\n                    }\n                }\n\n\n\n                // OK - we might have the prefix and URI\n                // Lets start our search for the next ST\n                // past this index\n\n                {\n                    let match = this._osc_st.exec( this._buffer );\n\n                    if (match === null)\n                    {\n                        pkt.kind = PacketKind.Incomplete;\n                        return pkt;\n                    }\n\n                    // If an illegal character was found, bail on the match\n                    if (match[3])\n                    {\n                        // Illegal sequence, just remove the ESC\n                        pkt.kind = PacketKind.ESC;\n                        pkt.text = this._buffer.slice(0, 1);\n                        this._buffer = this._buffer.slice(1);\n                        return pkt;\n                    }\n                }\n\n                // OK, at this point we should have a FULL match!\n                //\n                // Lets try to match that now\n\n                if (!this._osc_regex) {\n\n                    this._osc_regex = rgx`\n                        ^                           # beginning of line\n                                                    #\n                        \\x1b\\]8;                    # OSC Hyperlink\n                        [\\x20-\\x3a\\x3c-\\x7e]*       # params (excluding ;)\n                        ;                           # end of params\n                        ([\\x21-\\x7e]{0,512})        # URL capture\n                        (?:                         # ST\n                          (?:\\x1b\\\\)                  # ESC \\\n                          |                           # alternate\n                          (?:\\x07)                    # BEL (what xterm did)\n                        )\n                        ([\\x20-\\x7e]+)              # TEXT capture\n                        \\x1b\\]8;;                   # OSC Hyperlink End\n                        (?:                         # ST\n                          (?:\\x1b\\\\)                  # ESC \\\n                          |                           # alternate\n                          (?:\\x07)                    # BEL (what xterm did)\n                        )\n                    `;\n                }\n\n                let match = this._buffer.match(this._osc_regex);\n\n                if (match === null)\n                {\n                    // Illegal sequence, just remove the ESC\n                    pkt.kind = PacketKind.ESC;\n                    pkt.text = this._buffer.slice(0, 1);\n                    this._buffer = this._buffer.slice(1);\n                    return pkt;\n                }\n\n                // match is an array\n                // 0 - total match\n                // 1 - URL\n                // 2 - Text\n\n                // If a valid SGR\n                pkt.kind = PacketKind.OSCURL;\n                pkt.url  = match[1];\n                pkt.text = match[2];\n\n                var rpos = match[0].length;\n                this._buffer = this._buffer.slice(rpos);\n                return pkt;\n            }\n            else\n            // Other ESC CHECK\n            if (next_char == '(')\n            {\n                // This specifies the character set, which\n                // should just be ignored\n\n                // We have at least 3, so drop the sequence\n                pkt.kind = PacketKind.Unknown;\n                this._buffer = this._buffer.slice(3);\n                return pkt;\n            }\n        }\n    }\n\n    ansi_to_html(txt:string):string {\n\n        this.append_buffer(txt);\n\n        var blocks:string[] = [];\n\n        while (true)\n        {\n            var packet = this.get_next_packet();\n\n            if (    (packet.kind == PacketKind.EOS)\n                 || (packet.kind == PacketKind.Incomplete)  )\n                break;\n\n            //Drop single ESC or Unknown CSI\n            if (    (packet.kind == PacketKind.ESC)\n                 || (packet.kind == PacketKind.Unknown)  )\n                continue;\n\n            if (packet.kind == PacketKind.Text)\n                blocks.push( this.transform_to_html(this.with_state(packet)) );\n            else\n            if (packet.kind == PacketKind.SGR)\n                this.process_ansi(packet);\n            else\n            if (packet.kind == PacketKind.OSCURL)\n                blocks.push( this.process_hyperlink(packet) );\n        }\n\n        return blocks.join(\"\");\n    }\n\n    private with_state(pkt:TextPacket):TextWithAttr {\n        return { bold: this.bold, italic: this.italic, underline: this.underline, fg: this.fg, bg: this.bg, text: pkt.text };\n    }\n\n    private process_ansi(pkt:TextPacket)\n    {\n      // Ok - we have a valid \"SGR\" (Select Graphic Rendition)\n\n      let sgr_cmds = pkt.text.split(';');\n\n      // Each of these params affects the SGR state\n\n      // Why do we shift through the array instead of a forEach??\n      // ... because some commands consume the params that follow !\n      while (sgr_cmds.length > 0) {\n          let sgr_cmd_str = sgr_cmds.shift();\n          let num = parseInt(sgr_cmd_str, 10);\n\n          if (isNaN(num) || num === 0) {\n              this.fg = this.bg = null;\n              this.bold = false;\n              this.italic = false;\n              this.underline = false;\n          } else if (num === 1) {\n              this.bold = true;\n          } else if (num === 3) {\n              this.italic = true;\n          } else if (num === 4) {\n              this.underline = true;\n          } else if (num === 22) {\n              this.bold = false;\n          } else if (num === 23) {\n              this.italic = false;\n          } else if (num === 24) {\n              this.underline = false;\n          } else if (num === 39) {\n              this.fg = null;\n          } else if (num === 49) {\n              this.bg = null;\n          } else if ((num >= 30) && (num < 38)) {\n              this.fg = this.ansi_colors[0][(num - 30)];\n          } else if ((num >= 40) && (num < 48)) {\n              this.bg = this.ansi_colors[0][(num - 40)];\n          } else if ((num >= 90) && (num < 98)) {\n              this.fg = this.ansi_colors[1][(num - 90)];\n          } else if ((num >= 100) && (num < 108)) {\n            this.bg = this.ansi_colors[1][(num - 100)];\n          } else if (num === 38 || num === 48) {\n\n              // extended set foreground/background color\n\n              // validate that param exists\n              if (sgr_cmds.length > 0) {\n                  // extend color (38=fg, 48=bg)\n                  let is_foreground = (num === 38);\n\n                  let mode_cmd = sgr_cmds.shift();\n\n                  // MODE '5' - 256 color palette\n                  if (mode_cmd === '5' && sgr_cmds.length > 0) {\n                      let palette_index = parseInt(sgr_cmds.shift(), 10);\n                      if (palette_index >= 0 && palette_index <= 255) {\n                          if (is_foreground)\n                              this.fg = this.palette_256[palette_index];\n                          else\n                              this.bg = this.palette_256[palette_index];\n                      }\n                  }\n\n                  // MODE '2' - True Color\n                  if (mode_cmd === '2' && sgr_cmds.length > 2) {\n                      let r = parseInt(sgr_cmds.shift(), 10);\n                      let g = parseInt(sgr_cmds.shift(), 10);\n                      let b = parseInt(sgr_cmds.shift(), 10);\n\n                      if ((r >= 0 && r <= 255) && (g >= 0 && g <= 255) && (b >= 0 && b <= 255)) {\n                          let c = { rgb: [r,g,b], class_name: 'truecolor'};\n                          if (is_foreground)\n                              this.fg = c;\n                          else\n                              this.bg = c;\n                      }\n                  }\n              }\n          }\n      }\n    }\n\n    private transform_to_html(fragment:TextWithAttr):string {\n        let txt = fragment.text;\n\n        if (txt.length === 0)\n            return txt;\n\n        txt = this.escape_txt_for_html(txt);\n\n        // If colors not set, default style is used\n        if (!fragment.bold && !fragment.italic && !fragment.underline && fragment.fg === null && fragment.bg === null)\n            return txt;\n\n        let styles:string[] = [];\n        let classes:string[] = [];\n\n        let fg = fragment.fg;\n        let bg = fragment.bg;\n\n        // Note on bold: https://stackoverflow.com/questions/6737005/what-are-some-advantages-to-using-span-style-font-weightbold-rather-than-b?rq=1\n        if (fragment.bold)\n            styles.push('font-weight:bold');\n        \n        if (fragment.italic)\n            styles.push('font-style:italic');\n\n        if (fragment.underline)\n            styles.push('text-decoration:underline');\n\n        if (!this._use_classes) {\n            // USE INLINE STYLES\n            if (fg)\n                styles.push(`color:rgb(${fg.rgb.join(',')})`);\n            if (bg)\n                styles.push(`background-color:rgb(${bg.rgb})`);\n        } else {\n            // USE CLASSES\n            if (fg) {\n                if (fg.class_name !== 'truecolor') {\n                    classes.push(`${fg.class_name}-fg`);\n                } else {\n                    styles.push(`color:rgb(${fg.rgb.join(',')})`);\n                }\n            }\n            if (bg) {\n                if (bg.class_name !== 'truecolor') {\n                    classes.push(`${bg.class_name}-bg`);\n                } else {\n                    styles.push(`background-color:rgb(${bg.rgb.join(',')})`);\n                }\n            }\n        }\n\n        let class_string = '';\n        let style_string = '';\n\n        if (classes.length)\n            class_string = ` class=\"${classes.join(' ')}\"`;\n\n        if (styles.length)\n            style_string = ` style=\"${styles.join(';')}\"`;\n\n        return `<span${style_string}${class_string}>${txt}</span>`;\n    };\n\n    private process_hyperlink(pkt:TextPacket):string\n    {\n        // Check URL scheme\n        let parts = pkt.url.split(':');\n        if (parts.length < 1)\n            return '';\n\n        if (! this._url_whitelist[parts[0]])\n            return '';\n\n        let result = `<a href=\"${this.escape_txt_for_html(pkt.url)}\">${this.escape_txt_for_html(pkt.text)}</a>`;\n        return result;\n    }\n}\n\n//\n// PRIVATE FUNCTIONS\n//\n\n// ES5 template string transformer\nfunction rgx(tmplObj, ...subst) {\n    // Use the 'raw' value so we don't have to double backslash in a template string\n    let regexText:string = tmplObj.raw[0];\n\n    // Remove white-space and comments\n    let wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n    let txt2 = regexText.replace(wsrgx, '');\n    return new RegExp(txt2);\n}\n\n// ES5 template string transformer\n// Multi-Line On\nfunction rgxG(tmplObj, ...subst) {\n    // Use the 'raw' value so we don't have to double backslash in a template string\n    let regexText:string = tmplObj.raw[0];\n\n    // Remove white-space and comments\n    let wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n    let txt2 = regexText.replace(wsrgx, '');\n    return new RegExp(txt2, 'g');\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}